import sys
sys.stdin = open('1600.txt', 'r')
'''

동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 
그 녀석은 말(Horse)이 되기를 간절히 원했다. 
그래서 그는 말의 움직임을 유심히 살펴보고 그대로 따라 하기로 하였다. 

말은 말이다. 말은 격자판에서 체스의 나이트와 같은 이동방식을 가진다. 
다음 그림에 말의 이동방법이 나타나있다. 
1) x표시한 곳으로 말이 갈 수 있다는 뜻이다. 
2) 참고로 말은 장애물을 뛰어넘을 수 있다.

근데 원숭이는 한 가지 착각하고 있는 것이 있다. 
말은 저렇게 움직일 수 있지만 원숭이는 능력이 부족해서 
1) 총 K번만 위와 같이 움직일 수 있고, 
2) 그 외에는 그냥 인접한 칸으로만 움직일 수 있다. 
3) 대각선 방향은 인접한 칸에 포함되지 않는다.

이제 원숭이는 머나먼 여행길을 떠난다. 
격자판의 맨 왼쪽 위에서 시작해서 맨 오른쪽 아래까지 가야한다. 
1) 0, 0 -> H-1, W-1

인접한 네 방향으로 한 번 움직이는 것, 
말의 움직임으로 한 번 움직이는 것, 
모두 한 번의 동작으로 친다. 

격자판이 주어졌을 때, 
원숭이가 최소한의 동작으로 
시작지점에서 도착지점까지 갈 수 있는 방법을 알아내는 프로그램을 작성하시오.

# K를 쓰는가 안쓰는가를 확인하면서 모든 경우의 수를 헤집을것
# 최소한의 동작으로 도착이므로, 최단거리라고 볼 수 있어서 BFS로 한다.
'''


'''
입력
첫째 줄에 자연수 K가 주어진다. 둘째 줄에 격자판의 가로길이 W, 세로길이 H가 주어진다. 
그 다음 H줄에 걸쳐 W개의 숫자가 주어지는데, 
0은 아무것도 없는 평지, 1은 장애물을 뜻한다. 장애물이 있는 곳으로는 이동할 수 없다. 
시작점과 도착점은 항상 평지이다. W와 H는 1이상 200이하의 자연수이고, K는 0이상 30이하의 정수이다.

출력
첫째 줄에 원숭이의 동작수의 최솟값을 출력한다. 시작점에서 도착점까지 갈 수 없는 경우엔 -1을 출력한다.



1. 능력이 있을 경우에는 knight처럼 움직이고 해당 위치를 큐에 집어넣고, 
   능력이 없을 때처럼 움직이는 경우도 큐에 집어넣습니다.
-> 이 때, visited 함수를 좌표와 능력 사용 횟수를 이용해 표시하는 것이 핵심입니다! 
즉, 같은 좌표라도 능력 사용 횟수가 다르면 visited 함수는 표시가 되어있지 않습니다.

2. 도착지점에 도달할 경우 움직인 횟수를 반환합니다.
'''

def solve(y, x):
    pass

K = int(input())
W, H = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(H)]
print(K, W, H)
print(board)
solve(0, 0)




#
#
# ## 1600_말이 되고픈 원숭이
# ​
# ##### 코드
# ​
# ```python
# import collections
# ​
# ​
# K = int(input())
# W, H = map(int, input().split())
# ​
# board = [list(map(int, input().split())) for _ in range(H)]
# dp = [[[] for _ in range(W)] for _ in range(H)]
# adj_list = [(-1, 0), (0, 1), (1, 0), (0, -1)]
# jump_list = [(-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)]
# ​
# queue = collections.deque([(0, 0, 0, K)])  # (row, col, 지금까지 움직임 수, 남은 horse 점프)
# flag = False  # 도착해서 끝났는지 아니면 더이상 갈 곳이 없어서 끝났는지 구분하기 위한 flag
# ​
# while queue:
#     idx1, idx2, n, j = queue.popleft()
#
#     if idx1 == H - 1 and idx2 == W - 1:  # 도착점이면 flag = True, break
#         flag = True
#         break
#
#     else:
#         for adj in adj_list:  # 인접한 네 방향으로의 움직임
#             nxt1, nxt2 = idx1 + adj[0], idx2 + adj[1]
#             if 0 <= nxt1 < H and 0 <= nxt2 < W:
#                 if board[nxt1][nxt2] == 0:  # 장애물이 없고
#                     if j not in dp[nxt1][nxt2]:  # 다음 갈 곳 dp에 같은 점프 수로 이미 왔었니?
#                         dp[nxt1][nxt2].append(j)  # 아니라면 dp에 남은 점프 수를 넣고
#                         queue.append((nxt1, nxt2, n + 1, j))  # queue에도 넣어줘
#
#                     # 같은 점프 수로 같은 칸에 왔어도 그때의 움직임 수(n)보다 지금 움직임 수가
#                     # 무조건 작거나 같으므로 (queue니까) 무시해도 됩니다.
#
#         if j > 0:  # 만약에 남은 점프 수가 0이 아니라면
#             for jump in jump_list:  # 점프할 수 있는 8방향에 대해서
#                 nxt1, nxt2 = idx1 + jump[0], idx2 + jump[1]
#                 if 0 <= nxt1 < H and 0 <= nxt2 < W:
#                     if board[nxt1][nxt2] == 0:
#                         if j - 1 not in dp[nxt1][nxt2]:
#                             # 다음 갈 곳에 같은 점프 수(j - 1)로 왔었니?
#                             # 이때 점프를 해서 도착하는 거니까 남은 점프 수 => j - 1
#                             dp[nxt1][nxt2].append(j - 1)  # 없으면 dp랑 queue에 넣어줘
#                             queue.append((nxt1, nxt2, n + 1, j - 1))
#
# if flag is True:
#     print(n)
# else:
#     print(-1)
# ```
# ​
# ​
# ​
# 예제
# 1
# ​
# ```
# 1
# 4
# 4
# 0
# 0
# 0
# 0
# 1
# 0
# 0
# 0
# 0
# 0
# 1
# 0
# 0
# 1
# 0
# 0
# ```
# ​
# pprint(dp)
# ​
# ```python
# # n == 0 일때 (0 번 움직였을 때) dp 는
# [[[], [], [], []],
#  [[], [], [], []],
#  [[], [], [], []],
#  [[], [], [], []]]
# ​
# # n == 1 일때, 즉 한번 움직여서 갈 수 있는 곳 표시
# [[[], [1], [], []],  # (0, 1) -> [1]	 점프가 1번 남았을 때 이 위치에 왔음을 보여준다.
#  [[], [], [0], []],  # (1, 2) -> [0]	 점프가 0번 남았을 때 (한번 썼을 때) 여기 왔다.
#  [[], [0], [], []],
#  [[], [], [], []]]
# ​
# # n == 2 일때,
# [[[1], [1], [1, 0], []],  # (0, 2)->[1, 0] 점프가 1번 남았을 때, 점프가 0번 남았을 때 이미 왔다감
#  [[], [1, 0], [0], [0]],
#  [[0], [0], [], []],
#  [[], [], [], []]]
# ​
# # n == 3 일때
# [[[1], [1, 0], [1, 0], [1, 0]],
#  [[], [1, 0], [0, 1], [0]],
#  [[0], [0, 1], [], [0]],
#  [[0], [], [0], []]]
# ​
# # n == 4 일때
# [[[1, 0], [1, 0], [1, 0], [1, 0]],
#  [[], [1, 0], [0, 1], [0, 1]],
#  [[0, 1], [0, 1], [], [0]],
#  [[0], [], [0], [0]]]  # 도착지점에 도착 => break	=> 답: n = 4
# ```
